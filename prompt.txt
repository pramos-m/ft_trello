Modifica mi código para que tenga los estilos que se ven en las imágenes. Haz que sea lo más fiel al diseño.

Para ola segunda foto, hay que crear esos botones, y el componente tambien de estás seguro que quieres eliminar?

Y para la foto del menú, quiero que sea otro componente desplegable , aunque esté el menú vacío, más adelante se implementará.

Para los botones de eliminar y favoritos, se hará una petición a la API de una app MERN. Se implementará mañana. Puedes dejar como una plantilla.

Recuerda que lo más importante es el diseño ya que las funcionalidad ya está (menso el menú y el botón):

board.jsx:

import { useState } from 'react';

import { motion } from 'framer-motion';

import { useBoard } from '../context/BoardContext';

import Column from '../components/board/Column';

import AddColumn from '../components/board/AddColumn';

import { Trash2 } from 'lucide-react';

export default function Board() {

const { columns, deleteCard, deleteColumn } = useBoard();

const [draggingCard, setDraggingCard] = useState(null);

const [isDraggingColumn, setIsDraggingColumn] = useState(false);

const [isDraggingOverTrash, setIsDraggingOverTrash] = useState(false);

const handleTrashDragOver = (e) => {

e.preventDefault();

setIsDraggingOverTrash(true);

 };

const handleTrashDragLeave = () => {

setIsDraggingOverTrash(false);

 };

const handleTrashDrop = (e) => {

e.preventDefault();

const columnId = e.dataTransfer.getData('columnId');

if (columnId && columns[columnId]) {

deleteColumn(columnId);

 } else if (draggingCard) {

const columnId = Object.keys(columns).find((colId) =>

columns[colId].cards.some((card) => card.id === draggingCard.id)

 );

if (columnId) {

deleteCard(columnId, draggingCard.id);

 }

 }

setIsDraggingOverTrash(false);

setDraggingCard(null);

 };

return (

<div className="min-h-screen bg-neutral-grey-50">

<header className="border-b border-neutral-grey-200 bg-white px-6 py-4">

<h1 className="text-xl font-medium text-neutral-grey-800">Mallorca</h1>

</header>

<div className="p-6">

<div className="flex items-start gap-4 overflow-x-auto pb-4">

<motion.div className="flex gap-4" >

{Object.values(columns).length === 0 ? (

<AddColumn />

 ) : (

<>

{Object.values(columns).map((column, index) => (

<Column

key={column.id}

column={column}

draggingCard={draggingCard}

setDraggingCard={setDraggingCard}

index={index}

isDraggingColumn={isDraggingColumn}

setIsDraggingColumn={setIsDraggingColumn}

/>

 ))}

<AddColumn />

</>

 )}

</motion.div>

</div>

</div>

<div

className={`fixed bottom-6 right-6 rounded-lg border-2 ${

isDraggingOverTrash

 ? 'border-red-500 bg-red-100'

 : 'border-neutral-grey-300 bg-white'

} p-4 shadow-lg transition-colors`}

onDragOver={handleTrashDragOver}

onDragLeave={handleTrashDragLeave}

onDrop={handleTrashDrop}

>

<Trash2

size={24}

className={isDraggingOverTrash ? 'text-red-500' : 'text-neutral-grey-600'}

/>

</div>

</div>

 );

}

tailwind.config.js:

// tailwind.config.js

export default {

content: ["./index.html", "./src/**/*.{js,jsx}"], // Asegúrate de incluir los archivos donde usas clases Tailwind

theme: {

extend: {

fontFamily: {

sans: ["Roboto", "sans-serif"],

inter: ["Inter", "sans-serif"],

leira: ["Leira Lite", "sans-serif"],

dangerless: ["Dangerless Liaisons", "sans-serif"],

pompiere: ["Pompiere", "sans-serif"],

 },

colors: {

neutral: {

DEFAULT: "#FFFFFF",

grey: {

50: "#F8F9FA",

100: "#F1F3F5",

200: "#E9ECEF",

300: "#DEE2E6",

400: "#CED4DA",

DEFAULT: "#ADB5BD",

600: "#868E96",

700: "#495057",

800: "#343A40",

900: "#212529",

 },

black: "#000000",

 },

btn: {

blue: "#1A50D2",

grey: {

DEFAULT: "#757575",

selected: "#D9D9D9",

optionSelected: "#F2F4F7",

iron: "#DADCE0",

 },

 },

cards: {

iceberg: "rgba(220, 240, 255, 0.7)",

aqua: "rgba(229, 251, 239, 0.7)",

yellow: {

dawn: "rgba(254, 250, 227, 0.7)",

 },

pink: {

dawn: "rgba(252, 233, 230, 0.7)",

carousel: "rgba(244, 228, 229, 0.7)",

 },

purple: {

lavender: "rgba(231, 226, 252, 0.1)",

 },

blue: {

lavender: "#DFE9FE",

 },

 },

blurBackground: {

light: "rgba(0, 0, 0, 0.2)",

dark: "rgba(241, 244, 254, 1)",

 },

priority: {

low: "rgba(20, 174, 92, 1)",

medium: "rgba(191, 106, 2, 1)",

high: "rgba(192, 15, 12, 1)",

 },

logos: {

blue: {

dark: "#011E9A",

navy: "#05183F",

DEFAULT: "#1A50D2",

light: "#A6C2F7",

 },

grey: {

DEFAULT: "#D9D9D9",

text: "#3C4043",

light: "#B1B0B0",

lightest: "#F1F1F1",

 },

white: {

bluish: "#F1F4FF",

DEFAULT: "#FFFFFF",

 },

 },

 },

backgroundImage: {

logo: "url('/logo.svg')",

 },

 },

 },

 };

index.css:

@import url("https://fonts.googleapis.com/css2?family=Inter:wght@100;300&display=swap");

@import url("https://db.onlinewebfonts.com/c/8865c2ea1c416f5c17881dbb8b60a51d?family=Leira+Lite");

@import url('https://fonts.googleapis.com/css2?family=Pompiere&display=swap');

@tailwind base;

@tailwind components;

@tailwind utilities;

@font-face {

font-family: 'Dangerless Liaisons';

font-style: normal;

font-weight: 400;

src: local(''), url('https://fonts.cdnfonts.com/s/119354/DangerlessLiaisons-nAXnY.woff') format('woff');

}

.hide-scrollbar {

-ms-overflow-style: none;

scrollbar-width: none;

 }

.hide-scrollbar::-webkit-scrollbar {

display: none;

 }

.line-clamp-3 {

display: -webkit-box;

-webkit-line-clamp: 3;

-webkit-box-orient: vertical;

overflow: hidden;

 }

/* Estilo para cuando la card está siendo arrastrada */

.dragging-card {

opacity: 0.5;

transform: scale(1.05); /* Aumenta un poco al arrastrar */

 }

.cards-container > div {

transition: transform 0.2s ease, height 0.2s ease;

 }

.line-clamp-description {

display: -webkit-box;

-webkit-line-clamp: 4;

-webkit-box-orient: vertical;

overflow: hidden;

text-overflow: ellipsis;

max-height: calc(1.5em * 4);

 }

.card-dragging {

transform: rotate(2deg);

box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);

 }

.card {

max-width: 100%;

width: 100%;

min-height: 48px;

 }

.card p {

margin: 0;

padding: 0;

 }

 board context.js

import { createContext, useContext, useState } from 'react';

const BoardContext = createContext();

export function BoardProvider({ children }) {

const [columns, setColumns] = useState({});

const addCard = (columnId, card) => {

setColumns((prev) => ({

...prev,

[columnId]: {

...prev[columnId],

cards: [...prev[columnId].cards, card],

 },

 }));

 };

const updateCard = (columnId, cardId, updates) => {

setColumns((prev) => {

const newColumns = { ...prev };

const cardIndex = newColumns[columnId].cards.findIndex((card) => card.id === cardId);

if (cardIndex !== -1) {

newColumns[columnId].cards[cardIndex] = {

...newColumns[columnId].cards[cardIndex],

...updates,

 };

 }

return newColumns;

 });

 };

const deleteCard = (columnId, cardId) => {

setColumns((prev) => {

const newColumns = { ...prev };

newColumns[columnId].cards = newColumns[columnId].cards.filter(

 (card) => card.id !== cardId

 );

return newColumns;

 });

 };

const addColumn = (title) => {

const newColumnId = column-${Date.now()};

setColumns((prev) => ({

...prev,

[newColumnId]: {

id: newColumnId,

title,

description: '',

cards: [],

 },

 }));

 };

const updateColumn = (columnId, updates) => {

setColumns((prev) => ({

...prev,

[columnId]: {

...prev[columnId],

...updates,

 },

 }));

 };

const deleteColumn = (columnId) => {

setColumns((prev) => {

const { [columnId]: _, ...rest } = prev;

return rest;

 });

 };

const moveCard = (fromColumnId, toColumnId, cardId, targetIndex) => {

setColumns((prev) => {

const newColumns = { ...prev };

const fromColumn = newColumns[fromColumnId];

const toColumn = newColumns[toColumnId];

const card = fromColumn.cards.find((c) => c.id === cardId);

if (card) {

fromColumn.cards = fromColumn.cards.filter((c) => c.id !== cardId);

if (fromColumnId === toColumnId) {

fromColumn.cards.splice(targetIndex, 0, card);

 } else {

toColumn.cards.splice(targetIndex, 0, card);

 }

 }

return newColumns;

 });

 };

const reorderColumns = (sourceIndex, destinationIndex) => {

setColumns((prev) => {

const columnIds = Object.keys(prev);

const [movedId] = columnIds.splice(sourceIndex, 1);

columnIds.splice(destinationIndex, 0, movedId);

const reorderedColumns = {};

columnIds.forEach((id) => {

reorderedColumns[id] = prev[id];

 });

return reorderedColumns;

 });

 };

const updateColumnDescription = (columnId, description) => {

setColumns((prev) => ({

...prev,

[columnId]: {

...prev[columnId],

description,

 },

 }));

 };

return (

<BoardContext.Provider

value={{

columns,

addCard,

updateCard,

deleteCard,

addColumn,

updateColumn,

deleteColumn,

moveCard,

reorderColumns,

updateColumnDescription,

 }}

>

{children}

</BoardContext.Provider>

 );

}

export const useBoard = () => useContext(BoardContext);

column.jsx:

card.jsx:

import { useState, useRef, useEffect } from "react";

import { motion } from "framer-motion";

import { useBoard } from "../../context/BoardContext";

const MAX_VISIBLE_CHARS = 383;

export default function Card({ card, columnId, index, setDraggingCard }) {

const { updateCard } = useBoard();

const [isEditing, setIsEditing] = useState(false);

const [title, setTitle] = useState(card.title);

const [description, setDescription] = useState(card.description || '');

const [isDragging, setIsDragging] = useState(false);

const cardRef = useRef(null);

const handleDragStart = (e) => {

e.stopPropagation();

setDraggingCard(card);

setIsDragging(true);

e.dataTransfer.effectAllowed = "move";

e.target.classList.add('dragging-card');

 };

const handleDragEnd = (e) => {

e.stopPropagation();

setDraggingCard(null);

setIsDragging(false);

e.target.classList.remove('dragging-card');

 };

useEffect(() => {

function handleClickOutside(event) {

if (cardRef.current && !cardRef.current.contains(event.target)) {

setIsEditing(false);

if (title !== card.title || description !== card.description) {

updateCard(columnId, card.id, { title, description });

 }

 }

 }

document.addEventListener('mousedown', handleClickOutside);

return () => document.removeEventListener('mousedown', handleClickOutside);

 }, [title, description, columnId, card.id, updateCard, card.title, card.description]);

const getTruncatedDescription = (text) => {

if (!text || text.length <= MAX_VISIBLE_CHARS) return text;

return text.substring(0, MAX_VISIBLE_CHARS) + '...';

 };

return (

<motion.div

ref={cardRef}

draggable

onDragStart={handleDragStart}

onDragEnd={handleDragEnd}

onClick={(e) => {

e.stopPropagation();

setIsEditing(true);

 }}

className={`card rounded-lg bg-white p-3 shadow-sm hover:shadow-md cursor-grab active:cursor-grabbing ${

isDragging ? 'opacity-0' : 'opacity-100'

}`}

style={{

transition: 'opacity 0.2s'

 }}

>

{isEditing ? (

<div className="flex flex-col gap-2">

<input

value={title}

onChange={(e) => setTitle(e.target.value)}

className="w-full rounded border border-neutral-300 px-2 py-1 text-sm"

placeholder="Enter title..."

autoFocus

/>

<textarea

value={description}

onChange={(e) => setDescription(e.target.value)}

className="w-full rounded border border-neutral-300 px-2 py-1 text-sm resize-vertical"

placeholder="Enter description..."

rows={3}

/>

</div>

 ) : (

<>

<h4 className="text-sm font-medium text-neutral-900 break-words">

{title}

</h4>

{description && (

<p className="mt-2 text-sm text-neutral-600 break-words">

{getTruncatedDescription(description)}

</p>

 )}

</>

 )}

</motion.div>

 );

}